import json
from etcd import Client as ClientClass

# overload some of the etcd class(es) with modified version(s) to reduce some of the overhead related to error trapping and the like.
class etld_client_wrapper( ClientClass ):
    # the etcd.Client.read throws a KeyError exception if the key is not found. This modification allows a default value to be
    # passed in instead of having to trap the exception continually.
    def read(self, key, default=None ):
        try:
            return super( etld_client_wrapper, self ).read( key )
        except KeyError:
            return default

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Create a logging object which logs to syslog and, if supplied Sentry. This component should be used in
#  preference to any other logging method in the core Quiddi systems.
#
class connect():
    'Quiddi common configuration access routine'

    def __init__( self, application, host=None, host_env=None ):
        """
        Creates a config object.

        application             - an indicator of which system config/data is required, e.g. rtb, QC, etc.
        host                    - alternative host from the default, etcd-lb
        """

        self.__config = {
            'host': 'etcd-lb',
            }

        # store the application defined by the caller
        self.__config['application'] = application

        # if an alternative etcd is defined then use that
        if host != None:
            self.__config['host'] = host

        if host_env != None:
            self.__config['host'] = ()
            for s in host_env.split( ',' ):
                p = 4001
                if ':' in s:
                    h,p = s.split( ':' )
                else:
                    h = s
                self.__config['host'] += ( ( h, int( p ) ), )

        # connect to the etcd and throw errors as would arise normally
        self.__config['client'] = etld_client_wrapper( host=self.__config['host'] )

#  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    def get_config( self ):
        # get the applications configuration from the <application>/config store.
        config = self.get( "%s/config" % self.__config['application'] )
        return config

#  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    def get( self, key ):
        """
        Get value for a key and 'turn' into a Python object

        target                  - key to read
        """

        # read the data value or return None
        config = self.__config['client'].read( key, None )
        payload = None

        # if a value exists for the key then turn the item from JSON into a native object
        if config:
            payload = json.loads( config.value )

        return payload
#  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    def set( self, key, data ):
        """
        Set a value for a given key.

        key                     - key name
        value                   - value to set
        """

        self.__config['config'].write( key, json.dumps( data ) )
