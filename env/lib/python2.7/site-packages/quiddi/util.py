import os, sys, logging, logging.handlers, inspect, pprint, requests, datetime, json, random
import ssl
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.poolmanager import PoolManager
import sched, time, threading
#scheduler = sched.scheduler(time.time, time.sleep)

# Hack taking the defined log level warnings and mapping them to the text equivalents. Review this in
# due course.
log_level_mapping = {
    '10': 'debug',
    '20': 'info',
    '30': 'warning',
    '40': 'error',
    '50': 'critical'
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# general purpose switch staement to be used instead of if, then, else blocks where evaluation is straight forward
# and usage aids legability.
class switch( object ):
    """
    Implementation of the switch statement.

    while switch( what ):
        if case( 'json' ):
            print( 'JSON' )
            break
        if case( 'xml' ):
            print( 'XML' )
            break
        print( 'unknown' )
        break
    """
    value = None
    def __new__( class_, value ):
        class_.value = value
        return True

def case( *args ):
    return any( ( arg == switch.value for arg in args ) )
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Create a logging object which logs to syslog and, if supplied Sentry. This component should be used in preference
# to any other logging method in the core Quiddi systems.
#
class logger():
    'Quiddi common logging routine'
    __logger = None
    __sentry = None

    def __init__( self, logger=None, level=None, name=None, sentry=None ):
        """
        Creates a logging object writing to syslog.

        logger          - app.logger or similar. If omitted then an object is created.
        level           - min logging level. If omitted then logging.WARN is used.
        name            - the name to log as. If omitted then the script name is used.
        sentry          - Sentry Client handle.
                          sentry = Client( dsn=app.config['SENTRY_DSN'] )
                          ql = logger( logger=app.logger, level=logging.DEBUG, sentry=sentry )
        """

        # if no logger is specified then create a new one
        if logger == None:
            logger = logging.getLogger( 'quiddi' )

        # if a Sentry object has been passed then store it
        if sentry != None:
            self.__sentry = sentry

        # use the logging level of the existing entity if there is non specified. If no logger is valid then use INFO
        if level == None:
            level = logger.getEffectiveLevel()

        # set the logging level
        logger.setLevel( level )

        # create the syslog handler and add it to the base handler passed in as logger
        sh = logging.handlers.SysLogHandler( address='/dev/log', facility=logging.handlers.SysLogHandler.LOG_LOCAL6 )

        # set the level to that defined when the object is created
        """
        Severity        Keyword         Description             General Description
        Critical        crit            Critical conditions.    Should be corrected immediately, but indicates failure in a secondary system,
                                                                an example is a loss of a backup ISP connection.
        Error           err (error)     Error conditions.       Non-urgent failures, these should be relayed to developers or admins;
                                                                each item must be resolved within a given time.
        Warning         warning (warn)  Warning conditions.     Not an error, but indication that an error will occur if action is not taken,
                                                                e.g. file system 85% full - each item must be resolved within a given time.
        Informational   info            Informational messages. Normal operational messages - may be harvested for reporting, measuring throughput,
                                                                etc. - no action required.
        Debug           debug           Debug-level messages.   Info useful to developers for debugging the application, not useful during operations.
        """
        sh.setLevel( level )
        formatter = logging.Formatter( '%(name)s - %(levelname)s - %(message)s' )
        sh.setFormatter( formatter )
        logger.addHandler( sh )

        # set a name if one hasn't been provided
        if name == None:
            program_name = ( sys.argv[0].split( '/' )[-1] ).split( '.' )
            del program_name[-1]
            name = '.'.join( program_name )

        # get the handle for it
        self.__logger = logging.getLogger( name )
#  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -
    def log( self, message, level=None, sentry=False, tags=None ):
        """
        Log a message to syslog.

        message         - <string> the message to write
        level           - logging.<level>. If omitted then the default log level used when creating the object is used.
        sentry          - <boolean>. Send the message to the Sentry server as well as log it to syslog
        tags            - additional tags to be used with the logging object. At present these are only applicable when
                          sentry=True. Sentry makes use of the tags.
        """
        # if no log level passed then use the current level
        if level == None:
            level = self.__logger.getEffectiveLevel()

        # get the stack less 1 place so we can report the actual log line and not the line in this function
        s = inspect.stack()[1]

        # if called form main then change the name of __main__ from <module> which is a little confusing
        func = s[3]
        if str( func ) == '<module>':
            func = '__main__'

        # get the line of code that's executing
        line = int( s[2] )

        # set the log level to the default if one is not provided
        if level == None:
            level = self.__logger.getEffectiveLevel()

        # if Sentry is and Sentry was defined when initialised then send the event to the Sentry server via the standard logger
        # processing along with any tags that might also have been passed in.
        if sentry and self.__sentry:
            self.__logger.log( level, '(%d)[sid=%s] %s:%d %s' % (
                    os.getpid(),
                    self.__sentry.get_ident(
                        self.__sentry.captureMessage(
                            message=message,
                            level=level,
                            tags=tags
                            )
                        ),
                    func,
                    line,
                    message
                    ) )
        else:
        # if Sentry was not set then log.
            self.__logger.log( level, '(%d) %s:%d %s' % ( os.getpid(), func, line, message ) )

def array_stepin( dest, path, value ):

    #print "===[path]>%s" % path
    keys = path.split( '/' )

    # only processed if we are at the end of the xpath
    if len( keys ) == 1:
        if isinstance( dest, list ):
            dest[int(path)] = value
        else:
            dest[path] = value
        return

    k = keys.pop( 0 )
    #print "====>%s" % k

    if isinstance( dest, dict ):
        #print "---->dict: %s=>%s" % ( '/'.join( keys ), pprint.pformat( dest ) )
        array_stepin( dest.get( k ), '/'.join( keys ), value )
    elif isinstance( dest, list):
        #print "---->list: %s=>%s" % ( '/'.join( keys ), pprint.pformat( dest ) )
        array_stepin( dest[int( k )], '/'.join( keys ), value )
    else:
        return

def grab(  d, p ):
    import dpath.util
    h = dict( (x, y) for x, y in dpath.util.search( d, p, yielded=True ))
    # look for and array subscripts in the dpath as these (stupidly) are not returned in the path when yielded.
    t = str( p )
    t = t.replace( '[', '' )
    t = t.replace( ']', '' )
    return h.get( t )

class SSLAdapter(HTTPAdapter):
    
    def __init__(self, ssl_version=None, **kwargs):
        self.ssl_version = ssl_version

        super(SSLAdapter, self).__init__(**kwargs)

    def init_poolmanager(self, connections, maxsize, block=False):
        self.poolmanager = PoolManager(num_pools=connections,
                                       maxsize=maxsize,
                                       block=block,
                                       ssl_version=self.ssl_version)

def send_log( ql, message, sentry, level, tags = {}):
    ql.log(message=message, sentry=sentry, level=level, tags=tags)


# def abort_process( ql, url, payload ):
#     send_log(ql, 'Hard read request failure: connecting to %s' % url, True, logging.ERROR)
#     send_log(ql, 'Hard read request failure: payload =  %s' % pprint.pformat(payload), False, logging.ERROR)
#     send_log(ql, 'Hard read request failure: worker shutting down', False, logging.ERROR)
#     os._exit(1)


def send_bid( buyer, mongodb, ql ):
    name = buyer.get_buyer_details.get('name')
    request = {
        "method" : buyer.get_buyer_details.get('deliver').get('method'),
        "url" : buyer.get_url,
        "data" : buyer.get_rendered_payload,
        "headers" : buyer.set_headers
    }

    timeout = {
        'connection': buyer.get_buyer_details.get('deliver').get('connection_timeout', 3),
        'read': buyer.get_buyer_details.get('deliver').get('read_timeout', 30)
    }

    #Setting up abort procedure if application takes over 3 minutes
    #send_log(ql, 'scheduler: creating abort_process event, runs in 30 seconds', False, logging.DEBUG)
    #event = scheduler.enter( 30, 1, abort_process, ( ql, buyer.get_url, buyer.get_rendered_payload ) )
    #abort_thread = threading.Thread(target=scheduler.run)
    #abort_thread.setDaemon(True)
    #send_log(ql, 'scheduler: abort_process event, starting on thread', False, logging.DEBUG)
    #abort_thread.start()

    response_payload = send(name, request, timeout, ql)

    #send_log(ql, 'scheduler: request succeeded, stopping abort_process event', False, logging.DEBUG)
    #scheduler.cancel( event )

    if response_payload['status_code'] in [503, 522, 408, 520]:
        buyer.audit_log('connection', response_payload['content'], mongodb, ql)

    return response_payload


def send(name, request, timeout, ql):

    response_payload = {
        'status_code' : 500,
        'request_time': datetime.datetime.now(),
    }
    url = request.get('url')
    request_session = requests.Session()
    request_session.mount( 'https://', SSLAdapter( ssl.PROTOCOL_SSLv23 ) )

    try:
        response = request_session.request(
            method = request.get('method'), 
            url = url,
            data = request.get('data', None),
            headers = request.get('headers', None),
            timeout = ( timeout.get('connection', 3), timeout.get('read', 30) ),
            verify = True
        )

        response_payload['status_code'] = response.status_code
        response_payload.update( {
            'content': response.content,
            'headers': dict(response.headers)
        } )

        send_log(ql, "%s response status code: %s" % (name, response.status_code), False, logging.DEBUG)
        send_log(ql, '%s response headers: %s' % (name, pprint.pformat(response.headers)), False, logging.DEBUG)
        send_log(ql, '%s response payload: %s' % (name, pprint.pformat(response.content)), False, logging.DEBUG)

    except requests.exceptions.ConnectionError as e:
        response_payload.update( {
            'status_code': 503,
            'content': 'connection error to %s, Reason: %s' % ( name, str(e) ),
            'headers': 'Connection_Error'
        } )
        tags = {
            'error': response_payload.get('headers', None),
            'url': url,
            'status_code': response_payload.get('status_code', None)
        }
        send_log(ql, response_payload.get('headers'), True, logging.ERROR, tags)
    except requests.exceptions.ConnectTimeout as e:
        response_payload.update( {
            'status_code': 522,
            'content': 'connection error to %s timed out after %d seconds' % ( url, timeout.get('connection', 3) ),
            'headers': 'Connect_Timeout_Error'
        } )
        tags = {
            'error': response_payload.get('headers', None),
            'url': url,
            'status_code': response_payload.get('status_code', None)
        }
        send_log(ql, response_payload.get('headers'), True, logging.ERROR, tags)
    except requests.exceptions.ReadTimeout as e:
        response_payload.update( {
            'status_code': 408,
            'content': 'timed out reading %s after %s seconds' % ( url, timeout.get('read', 30) ),
            'headers': 'Read_Error'
        } )
        tags = {
            'error': response_payload.get('headers', None),
            'url': url,
            'status_code': response_payload.get('status_code', None)
        }
        send_log(ql, response_payload.get('headers'), True, logging.ERROR, tags)
    except Exception as e:
        response_payload.update( {
            'status_code': 520,
            'content': 'Error occured with %s, Reason: %s' % ( url, e.message ),
            'headers': 'Catch-all_Error'
        } )
        tags = {
            'error': response_payload.get('headers', None),
            'url': url,
            'status_code': response_payload.get('status_code', None)
        }
        send_log(ql, response_payload.get('headers'), True, logging.ERROR, tags)

    return response_payload


def quiddi_default_encoder( obj, encoder=json.JSONEncoder() ):
    import bson
    from bson.objectid import ObjectId
    if isinstance( obj, ObjectId ):
        return str( obj )
    if isinstance(obj, datetime.datetime):
        return obj.strftime( '%Y-%m-%d %H:%M:%S' )
    return encoder.default( obj )
